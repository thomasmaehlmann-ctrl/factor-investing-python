{"title":"Risikobasierte Faktoren: Total Risk","markdown":{"yaml":{"title":"Risikobasierte Faktoren: Total Risk"},"headingText":"Hintergrund und Motivation","containsRefs":false,"markdown":"\n\n\n\n\n\n\n\nKlassische (\"rationale\") Finance-Theory (z.B. das CAPM) besagt, dass in einem effizienten Markt riskantere Aktien mit höherem erwarteten Risiko auch höhere erwartete Renditen versprechen sollten um Investoren für das größere Risiko zu kompensieren. Es gibt aber signifikante empirische Evidenz die diesen fundamentalen positiven Risiko-Rendite Zusammenhang in Frage stellt. Das empirische Phänomen in dem risikoarme (d.h., Low Risk) Aktien eine höhere Kompensation pro Einheit Risiko (das sogenannte *Alpha*) versprechen als riskante (d.h., High Risk) Aktien wird als die **Low Risk Anomalie (LRA)** bezeichnet. Ang (2014) und Baker, Bradley und Wurgler (2011) geben eine sehr lesenswerte Einführung in die empirische Signifikanz und in potentielle Erklärungen zur Existenz der LRA. Es kann dabei gründsätzlich zwischen den folgenden Erklärungsansätzen unterschieden werden: \n\n1. Lotterie-Präferenzen irrationaler Investoren kombiniert mit Arbitragebeschränkungen\n\nAuf Basis der kumulativen Prospekttheorie (Barberis und Huang, 2008) wird argumentiert, dass insbesondere individuelle (\"Retail\") Anleger kleine Chancen auf große Gewinne übergewichten. Sie besitzen demnach Lotteriepräferenzen. Infolgedessen bevorzugen sie Aktien mit positiver Schiefe (Skewness) in der Renditeverteilung. Diese Aktien sind dann aufgrund der erhöhten Nachfrage bei gegebenem Angebot überbewertet, was zu geringeren zukünftigen Renditen führt. Sind Aktienkursrisiko und Schiefe der Renditeverteilung positiv miteinander korreliert, können Lotteriepräferenzen die LRA erklären. Arbitragebeschränkungen in Form von Benchmarking und der Verzicht auf den Einsatz von Fremdkapital (siehe hierzu insbesondere Baker, Bradley und Wurgler, 2011) seitens institutioneller Investoren führen dazu, dass die LRA nicht \"arbitriert\" wird.\n\n2. Abweichungen vom Ideal eines friktionslosen Marktes (Market Frictions)\n\nDie zweite Gruppe von Erklärungen der LRA basiert auf sogenannten Market Frictions, also Abweichungen vom theoretischen Idealbild eines vollkommenen Marktes. Zu den Friktionen zählen insbesondere Transaktionskosten, Marktmikrostrukturverzerrungen wie der Bid-Ask Bounce oder eine kurzfristige Renditeumkehr (Mean Reversion). \n\n3. Erklärungen basierend auf Unsicherheit, Variance Beta, Earnings Surprises, etc.\n\n\nIm folgenden werden wir drei mögliche Wege im Form einer Faktorstrategie implementieren, mit dem Ziel eine potentiell vorhandene LRA auszunutzen. Im Kern geht es darum, High Risk (HR) und Low Risk (LR) Aktien zu identifizieren, und dann Long (Short) in die LR (HR) Aktien zu gehen. Die Strategierendite ergibt sich aus der Renditedifferenz zwischen dem Long und dem Short Portfolio. Wir messen die risikoadjustierte Strategierendite über die annualisierte Sharpe-Ratio. \n\nUnsere drei risikobasierten Faktorstrategien unterscheiden sich darin, wie wir das Aktienkursrisiko messen. Wir suchen also genau nach dem Risikomaß, das zukunftige Renditen am besten prognostiziert. Im ersten Fall verwenden wir die historische Renditestandardabweichung (*Total Risk*), im Zweiten die historische Standardabweichung der idiosynkratischen Renditen bzw. Renditeresiduen (*Idiosyncratic Volatility*), und schließlich das historische Aktienbeta (*Beta*).  \n\n## Beginn der Fallstudie\n\nFür unsere beispielhafte Implementierung risikobasierter Faktorstrategien zur Ausnutzung der LRA wählen wir als Anlageuniversum die Aktien des S&P500 für einen täglichen Zeitraum vom 3.1.2017 bis zum 14.11.2019. Die Daten sind im File \"s&p_500_15112019.csv\" enthalten. \n\n### Total Risk als Faktor\n\nLassen Sie uns beginnen und die Aktien des S&P500 an jedem Handelstag anhand ihrer vergangenen rollierenden historischen Renditestandardabweichung in Dezile  sortieren. Zunächst berechnen wir für jeden Tag die diskrete Rendite. Dies geschieht durch `px.pct_change()`. Wir speichern die Renditen im DataFrame `ret` und berechnen über `rolling(window, min_periods).std()` ein neues DataFrame `stdev` mit rollierenden täglichen historischen Renditestandardabweichungen. Wir müssen die Länge für das rollierende Zeitfenster (Argument `window`) und die Mindestanzahl an Renditebeobachtungen (Argument `min_periods`) zur Berechnung der Standardabweichung festlegen. \n\n### Implementierung 1: gleichgewichtete Dezil-Portfolios\n\nDanach bringen wir die Aktien über die Methode `rank(axis=1, pct=True)` in eine Perzentil-Rankordnung gemäß der vergangenen Renditestandardabweichung. Aus den Perzentilen können wir Dezile generieren indem wir mit 10 multiplizieren (`mul(10)`) und dann auf die nächste ganze Zahl aufrunden (`np.ceil`). Wollen wir Aktien alternativ in Quintile sortieren, multiplizieren wir einfach mit 5 (`mul(5)`). **Wichtig:** durch die Festlegung `ascending=False` werden Aktien mit den höchsten (geringsten) Standardabweichungen in Gruppe 1 (10) sortiert. Äquivalent werden bei `ascending=True` die riskanten Aktien in Gruppe 10 und die risikoarmen Aktien in Gruppe 1 sortiert. \n\nWir transformieren das DataFrame `rank_df` nun in ein DataFrame mit Positionsindikatoren: -1 für eine Short Position in Dezil 1 Aktien, 0 für eine Flat (d.h. keine) Position in Aktien der Dezile 2 bis 9, und 1 für eine Long Position in Dezil 10 Aktien. \n\n**Beachten Sie**: Da wir Long in Dezil 10 und Short in Dezil 1 gehen, implementieren wir durch die Wahl von `ascending=True` eine High-Risk Strategie, und durch `ascending=False` eine Low-Risk Strategie!\n\nFühren wir nun alles zusammen in der Funktion `weights_dc_equal`. Diese Funktion erfordert als Eingabe ein DataFrame mit Aktienpreisen (*price*), die Angabe des Zeitraums (*window*) für die Berechnung der historischen Renditestandardabweichung als Ranking-Faktor, die Minimum-Anzahl (*min_periods*) an Renditebeobachtungen, und die Anzahl der Tage (*lag*) die bis zur Implementierung der Strategie vergehen (sollen). \n\nZudem definieren wir wieder unsere zwei **Lambda** Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\nIm folgenden berechnen wir zunächst für jeden Handelstag die nicht-normierten Aktiengewichte (-1: Short; 0: Flat; 1: Long) durch Anwendung unserer Funktion `weights_dc_equal`. Das resultierende DataFrame nennen wir `port`. Dann legen wir die Anzahl der Handelstage (*hold*) fest, für die wir das Portfolio halten wollen ohne die Gewichte umzuschichten. \n\nIm letzten Schritt reduzieren wir die Zeitfrequenz von `port` auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.  \n\nDann berechnen wir die kumulativen Renditen jeder Aktie für die gewählte Portfoliohaltedauer. Hierzu verwenden wir die vorher definierte Lambda-Funktion `compound`.  \n\nDanach multiplizieren wir für jede der einzelnen Halteperioden die kumulativen Aktienrenditen mit den Positionsindikatoren (-1, 0, 1), summieren die Produkte über alle Aktien auf, und teilen durch die Summe aller offen (Long und Short) Positionen um eine gleichgewichtete Portfoliorendite zu bekommen. Die resultierende Zeitreihe der kumulativen Portfoliorenditen nennen wir `portf_rets`. Sie hat dieselbe Zeitfrequenz wie *freq*, die Portfoliohaltedauer in Anzahl Handelstage. Wenden wir unsere Lambda-Funktion `daily_sr`auf die Zeitreihe der Portfoliorenditen an und skalieren mit `np.sqrt(252/hold)` erhalten wir die annualisierte Sharpe-Ratio der Strategie. \n\nLassen Sie uns nun die obigen Schritte in der Strategie-Funktion `strat_dc_equal` zusammenfassen. Wir benötigen ein DataFrame (*prices*) mit Aktienkursen, die Länge der lookback (*window*) Periode zur Berechnung der historischen Renditestandardabweichung (Rankingfaktor), und die Länge der Portfoliohaltedauer (*hold*). \n\nFühren wir die Strategie nun beispielhaft mit einer Halteperiode von einem Monat (21 Handelstage) aus. Die Aktien des S&P500 werden anhand ihrer vergangenen 40-Tage Renditestandardabweichung sortiert. Da in der Funktion `weights_dc_equal` `ascending=False` festgelegt ist, gehen wir also Long in die extremen 10% der vergangenen Low-Risk Aktien und Short in die extremen 10% der vergangenen High-Risk Aktien. Wir implementieren also eine Low-Risk Strategie!\n\n### Implementierung 2: Gewichte nach Frazzini und Pedersen (2014)\n\nZur Implementierung der FP Gewichte erstellen wir das gewohnte (tägliche) DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihrer Renditestandardabweichung über eine vergangene lookback (*window*) Periode. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. Zusätzlich enthält das DataFrame `abs_demeaned` die absoluten Rangabweichungen. Wir bekommen die finalen FP Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `weights_fp` zusammen. Alle weiteren Schritte erfolgen analog zur obigen Vorgehensweise. Die Strategiefunktion nenne ich `strat_fp`.  \n\n### Optimierung\n","srcMarkdownNoYaml":"\n\n\n\n\n\n\n## Hintergrund und Motivation\n\nKlassische (\"rationale\") Finance-Theory (z.B. das CAPM) besagt, dass in einem effizienten Markt riskantere Aktien mit höherem erwarteten Risiko auch höhere erwartete Renditen versprechen sollten um Investoren für das größere Risiko zu kompensieren. Es gibt aber signifikante empirische Evidenz die diesen fundamentalen positiven Risiko-Rendite Zusammenhang in Frage stellt. Das empirische Phänomen in dem risikoarme (d.h., Low Risk) Aktien eine höhere Kompensation pro Einheit Risiko (das sogenannte *Alpha*) versprechen als riskante (d.h., High Risk) Aktien wird als die **Low Risk Anomalie (LRA)** bezeichnet. Ang (2014) und Baker, Bradley und Wurgler (2011) geben eine sehr lesenswerte Einführung in die empirische Signifikanz und in potentielle Erklärungen zur Existenz der LRA. Es kann dabei gründsätzlich zwischen den folgenden Erklärungsansätzen unterschieden werden: \n\n1. Lotterie-Präferenzen irrationaler Investoren kombiniert mit Arbitragebeschränkungen\n\nAuf Basis der kumulativen Prospekttheorie (Barberis und Huang, 2008) wird argumentiert, dass insbesondere individuelle (\"Retail\") Anleger kleine Chancen auf große Gewinne übergewichten. Sie besitzen demnach Lotteriepräferenzen. Infolgedessen bevorzugen sie Aktien mit positiver Schiefe (Skewness) in der Renditeverteilung. Diese Aktien sind dann aufgrund der erhöhten Nachfrage bei gegebenem Angebot überbewertet, was zu geringeren zukünftigen Renditen führt. Sind Aktienkursrisiko und Schiefe der Renditeverteilung positiv miteinander korreliert, können Lotteriepräferenzen die LRA erklären. Arbitragebeschränkungen in Form von Benchmarking und der Verzicht auf den Einsatz von Fremdkapital (siehe hierzu insbesondere Baker, Bradley und Wurgler, 2011) seitens institutioneller Investoren führen dazu, dass die LRA nicht \"arbitriert\" wird.\n\n2. Abweichungen vom Ideal eines friktionslosen Marktes (Market Frictions)\n\nDie zweite Gruppe von Erklärungen der LRA basiert auf sogenannten Market Frictions, also Abweichungen vom theoretischen Idealbild eines vollkommenen Marktes. Zu den Friktionen zählen insbesondere Transaktionskosten, Marktmikrostrukturverzerrungen wie der Bid-Ask Bounce oder eine kurzfristige Renditeumkehr (Mean Reversion). \n\n3. Erklärungen basierend auf Unsicherheit, Variance Beta, Earnings Surprises, etc.\n\n\nIm folgenden werden wir drei mögliche Wege im Form einer Faktorstrategie implementieren, mit dem Ziel eine potentiell vorhandene LRA auszunutzen. Im Kern geht es darum, High Risk (HR) und Low Risk (LR) Aktien zu identifizieren, und dann Long (Short) in die LR (HR) Aktien zu gehen. Die Strategierendite ergibt sich aus der Renditedifferenz zwischen dem Long und dem Short Portfolio. Wir messen die risikoadjustierte Strategierendite über die annualisierte Sharpe-Ratio. \n\nUnsere drei risikobasierten Faktorstrategien unterscheiden sich darin, wie wir das Aktienkursrisiko messen. Wir suchen also genau nach dem Risikomaß, das zukunftige Renditen am besten prognostiziert. Im ersten Fall verwenden wir die historische Renditestandardabweichung (*Total Risk*), im Zweiten die historische Standardabweichung der idiosynkratischen Renditen bzw. Renditeresiduen (*Idiosyncratic Volatility*), und schließlich das historische Aktienbeta (*Beta*).  \n\n## Beginn der Fallstudie\n\nFür unsere beispielhafte Implementierung risikobasierter Faktorstrategien zur Ausnutzung der LRA wählen wir als Anlageuniversum die Aktien des S&P500 für einen täglichen Zeitraum vom 3.1.2017 bis zum 14.11.2019. Die Daten sind im File \"s&p_500_15112019.csv\" enthalten. \n\n### Total Risk als Faktor\n\nLassen Sie uns beginnen und die Aktien des S&P500 an jedem Handelstag anhand ihrer vergangenen rollierenden historischen Renditestandardabweichung in Dezile  sortieren. Zunächst berechnen wir für jeden Tag die diskrete Rendite. Dies geschieht durch `px.pct_change()`. Wir speichern die Renditen im DataFrame `ret` und berechnen über `rolling(window, min_periods).std()` ein neues DataFrame `stdev` mit rollierenden täglichen historischen Renditestandardabweichungen. Wir müssen die Länge für das rollierende Zeitfenster (Argument `window`) und die Mindestanzahl an Renditebeobachtungen (Argument `min_periods`) zur Berechnung der Standardabweichung festlegen. \n\n### Implementierung 1: gleichgewichtete Dezil-Portfolios\n\nDanach bringen wir die Aktien über die Methode `rank(axis=1, pct=True)` in eine Perzentil-Rankordnung gemäß der vergangenen Renditestandardabweichung. Aus den Perzentilen können wir Dezile generieren indem wir mit 10 multiplizieren (`mul(10)`) und dann auf die nächste ganze Zahl aufrunden (`np.ceil`). Wollen wir Aktien alternativ in Quintile sortieren, multiplizieren wir einfach mit 5 (`mul(5)`). **Wichtig:** durch die Festlegung `ascending=False` werden Aktien mit den höchsten (geringsten) Standardabweichungen in Gruppe 1 (10) sortiert. Äquivalent werden bei `ascending=True` die riskanten Aktien in Gruppe 10 und die risikoarmen Aktien in Gruppe 1 sortiert. \n\nWir transformieren das DataFrame `rank_df` nun in ein DataFrame mit Positionsindikatoren: -1 für eine Short Position in Dezil 1 Aktien, 0 für eine Flat (d.h. keine) Position in Aktien der Dezile 2 bis 9, und 1 für eine Long Position in Dezil 10 Aktien. \n\n**Beachten Sie**: Da wir Long in Dezil 10 und Short in Dezil 1 gehen, implementieren wir durch die Wahl von `ascending=True` eine High-Risk Strategie, und durch `ascending=False` eine Low-Risk Strategie!\n\nFühren wir nun alles zusammen in der Funktion `weights_dc_equal`. Diese Funktion erfordert als Eingabe ein DataFrame mit Aktienpreisen (*price*), die Angabe des Zeitraums (*window*) für die Berechnung der historischen Renditestandardabweichung als Ranking-Faktor, die Minimum-Anzahl (*min_periods*) an Renditebeobachtungen, und die Anzahl der Tage (*lag*) die bis zur Implementierung der Strategie vergehen (sollen). \n\nZudem definieren wir wieder unsere zwei **Lambda** Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\nIm folgenden berechnen wir zunächst für jeden Handelstag die nicht-normierten Aktiengewichte (-1: Short; 0: Flat; 1: Long) durch Anwendung unserer Funktion `weights_dc_equal`. Das resultierende DataFrame nennen wir `port`. Dann legen wir die Anzahl der Handelstage (*hold*) fest, für die wir das Portfolio halten wollen ohne die Gewichte umzuschichten. \n\nIm letzten Schritt reduzieren wir die Zeitfrequenz von `port` auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.  \n\nDann berechnen wir die kumulativen Renditen jeder Aktie für die gewählte Portfoliohaltedauer. Hierzu verwenden wir die vorher definierte Lambda-Funktion `compound`.  \n\nDanach multiplizieren wir für jede der einzelnen Halteperioden die kumulativen Aktienrenditen mit den Positionsindikatoren (-1, 0, 1), summieren die Produkte über alle Aktien auf, und teilen durch die Summe aller offen (Long und Short) Positionen um eine gleichgewichtete Portfoliorendite zu bekommen. Die resultierende Zeitreihe der kumulativen Portfoliorenditen nennen wir `portf_rets`. Sie hat dieselbe Zeitfrequenz wie *freq*, die Portfoliohaltedauer in Anzahl Handelstage. Wenden wir unsere Lambda-Funktion `daily_sr`auf die Zeitreihe der Portfoliorenditen an und skalieren mit `np.sqrt(252/hold)` erhalten wir die annualisierte Sharpe-Ratio der Strategie. \n\nLassen Sie uns nun die obigen Schritte in der Strategie-Funktion `strat_dc_equal` zusammenfassen. Wir benötigen ein DataFrame (*prices*) mit Aktienkursen, die Länge der lookback (*window*) Periode zur Berechnung der historischen Renditestandardabweichung (Rankingfaktor), und die Länge der Portfoliohaltedauer (*hold*). \n\nFühren wir die Strategie nun beispielhaft mit einer Halteperiode von einem Monat (21 Handelstage) aus. Die Aktien des S&P500 werden anhand ihrer vergangenen 40-Tage Renditestandardabweichung sortiert. Da in der Funktion `weights_dc_equal` `ascending=False` festgelegt ist, gehen wir also Long in die extremen 10% der vergangenen Low-Risk Aktien und Short in die extremen 10% der vergangenen High-Risk Aktien. Wir implementieren also eine Low-Risk Strategie!\n\n### Implementierung 2: Gewichte nach Frazzini und Pedersen (2014)\n\nZur Implementierung der FP Gewichte erstellen wir das gewohnte (tägliche) DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihrer Renditestandardabweichung über eine vergangene lookback (*window*) Periode. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. Zusätzlich enthält das DataFrame `abs_demeaned` die absoluten Rangabweichungen. Wir bekommen die finalen FP Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `weights_fp` zusammen. Alle weiteren Schritte erfolgen analog zur obigen Vorgehensweise. Die Strategiefunktion nenne ich `strat_fp`.  \n\n### Optimierung\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Risikobasierte Faktoren: Total Risk"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}