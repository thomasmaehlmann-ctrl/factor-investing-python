{"title":"Risikobasierte Faktoren: Stock Beta","markdown":{"yaml":{"title":"Risikobasierte Faktoren: Stock Beta"},"headingText":"Hintergrund und Motivation","containsRefs":false,"markdown":"\n\n\n\n\n\n\n\n\n\n\nEine Basisimplikation des Capital Asset Pricing Modells (CAPM) ist, dass alle Investoren in das Portfolio mit der höchsten erwarteten Überschussrendite pro Risikoeinheit (Sharpe Ratio) investieren und ihre Position in diesem Portfolio entsprechend ihrer Risikopräferenz mit Fremdkapital entweder hebeln (\"leveraging\" - erhöhen) oder enthebeln (\"de-leveraging\" – reduzieren). Viele Anleger, wie z.B. Privatpersonen, Pensionsfonds und Investmentfonds, haben jedoch nur eine eingeschränkte (oder gar keine) Möglichkeiten, Leverage (Fremdkapital) einzusetzen, und müssen daher riskante (High-Beta) Wertpapiere übergewichten, anstatt gehebelte Positionen in Low-Beta Aktien einzugehen. Diese aus Leveragebeschränkungen resultierende Präferenz für High-Beta Aktien kann dazu führen, dass im Gleichgewicht risikoreiche Wertpapiere mit hohem Beta niedrigere risikobereinigte Renditen erfordern als Wertpapiere mit niedrigem Beta, für die eine Hebelwirkung (d.h., eine Position unter Einsatz von Fremdkapital) erforderlich ist. Im Ergebnis bedeutet dies: **Low-Beta gleich High-Alpha**, und **High-Beta gleich Low-Alpha!** (Alpha bezeichnet hier risikoadjustierte Renditen)\n\nTatsächlich ist die Wertpapiermarktlinie für US-Aktien im Vergleich zum CAPM zu flach (Black, Jensen und Scholes, 1972) und lässt sich durch das CAPM mit eingeschränkter Kreditaufnahme besser erklären als durch das Standard-CAPM (siehe schon Black, 1972).\n\nIn einem viel zitierten Aufsatz stellen Frazzini und Pedersen (FP) (\"Betting against beta\", Journal of Financial Economics, 2014, p. 1-25) eine \"Long minus Short\" Faktorstrategie vor, mit dem Ziel die oben skizzierte **Beta Anomalie** auszunutzen. Sie konstruieren dabei einen \"Betting Against Beta\" (BAB) Faktor, der im Kern Low-Beta Aktien übergewichtet und High-Beta Aktien untergewichtet. Sie wenden die Faktorkonstruktion auf zahlreiche Assetklassen (US und 20 internationale Aktienmärkte, US-Staatsanleihen und Unternehmensanleihen, Future Märkte) an und können zeigen, dass die Faktorstrategie überall persistente, positive risikoadjustierte Renditen erwirtschaftet.  \n\nIm folgenden implementieren wir die Basisversion der FP BAB Faktorstrategie. \n\n## Beginn der Fallstudie\n\nWir beginnen mit dem Laden der notwendigen Pakete.\n\nWir setzen die BAB Faktorstrategie am Beispiel des S&P500 Universums um. Zunächst laden wir zwei Datensätze in Form von DataFrames, eines für die täglichen Aktienkurshistorien der S&P500 Mitglieder und eines für die Zeitreihe der Indexwerte des S&P500. Wir mergen beide Datensätze in dem DataFrame `joined_df`.\n\nWir werden in drei Schritten die BAB Faktorstrategie von FP implementieren. Zunächst schreiben wir eine Funktion (*calc_beta*), die den renditeprognostizierenden Faktor (das Aktienbeta zum Marktindex) für jede Aktie täglich auf Basis rollierender Zeitfenster berechnet. Danach verwenden wir diesen Faktor in der Funktion *bab_weights* um zwei Faktorportfolios zu bilden. Das Long (Low-Beta) Portfolio enthält Aktien mit niedrigem Beta, und das Short (High-Beta) Portfolio beinhaltet die Aktien, die stärker mit dem Markt variieren. In der dritten Funktion *bab_strat* führen wir alles zusammen, konstruieren den BAB \"Long minus Short\" Faktor, wobei die beiden Portfolios jeweils mit der Inversen ihres Betas skaliert werden, und berechnen für eine gegebene Halteperiode die annualisierte Sharpe-Ratio der Faktorstrategie. \n\n### Ex Ante Betas als Faktor\nDas geschätze $\\beta$ für Aktie $i$ ist definiert durch (siehe FP, 2014, Gleichung 14): \n\n$$\\beta^{TS}_{i}=\\rho\\frac{\\sigma_{i}}{\\sigma_{m}}$$\n\nHierbei sind $\\sigma_{i}$ und $\\sigma_{m}$ die historisch geschätzen Renditevolatilitäten der Aktie $i$ und des Marktes und $\\rho$ deren geschätzte Korrelation. FP schätzen Volatilitäten und Korrelationen separat. Konkret verwenden sie 1-Tages Log-Renditen für Volatilitäten und überlappende 3-Tages Log-Renditen für Korrelationen. Die jeweiligen gleitenden Zeitfenster für die täglichen rollierenden Schätzungen betragen 1 Jahr bei Volatilitäten und 5 Jahre für Korrelationen. \n\nUm den Einfluss von Ausreißern zu mindern werden die obigen (täglichen) Zeitreihen-Betas $\\beta^{TS}_{i}$ in Richtung des Querschnittsmittelwertes $\\beta^{XS}$ über folgende Gleichung geschrumpft (sogenannte \"Shrinkage\"-Schätzung; siehe FP, 2014, Gleichung 15):\n\n$$\\beta_{i}=w_{i}\\beta^{TS}_{i}+(1-w_{i})\\beta^{XS}$$\n\nZur Vereinfachung setzen FP $w=0.6$ und $\\beta^{XS}=1$ für alle Zeitpunkte und Wertpapiere. \n\n\nWir implementieren die Berechnung der FP Betas in der Funktion `calc_beta`. Diese benötigt als Eingabe ein DataFrame mit täglichen Historien an Aktienkursen und Marktindexwerten. Über `apply(lambda...)` erstellen wir jeweils DataFrames mit täglichen Zeitreihen von 1-Tages und überlappenden (kumulativen) 3-Tages Log-Renditen. Diese DataFrames werden über die `rolling`-Funktionalität transformiert in DataFrames mit Standardabweichungen (*stdev*), dem Verhältnis der Aktienvolatilität zur Marktvolatilität (*stdev_ratio*), und Renditekorrelationen (*corr*) mit dem Marktindex (Spalte 'SP_Index'). Die Zeitreihenbetas $\\beta^{TS}_{i}$ ergeben sich aus der zellenweisen Multiplikation von *corr* und *stdev_ratio*. Die geschrumpften Betas $\\beta_{i}$ sind im finalen DataFrame `beta_shrink` enthalten. \n\n### Konstruktion der Long-/Short-Portfolios\n\nUm ihren BAB-Faktor zu konstruieren, ordnen FP alle Wertpapiere im Datensatz zu jedem Zeitpunkt in aufsteigender Reihenfolge auf Grundlage der geschätzten Betas an (Perzentil-Ranking). Die geordneten Wertpapiere werden einem von zwei Portfolios zugewiesen: dem Low-Beta ($L$) und dem High-Beta ($H$) Portfolio. Der FP BAB Faktor basiert darauf, Long in das Low-Beta und Short in das High-Beta Portfolio zu gehen. Das Low- (High-) Beta Portfolio setzt sich aus allen Aktien zusammen, deren Beta unter (über) dem Median-Beta aller Wertpapiere im Datensatz liegt. In jedem Portfolio werden Wertpapiere anhand des Perzentil-Rangs ihres geschätzten Betas gewichtet. D.h., im Low-Beta Portfolio haben Wertpapiere mit niedrigerem Beta größere Gewichte, und im High-Beta Portfolio steigt entsprechend das Gewicht für Wertpapiere mit höherem Beta. Formal ergeben sich die Gewichtsvektoren der Aktien in beiden Portfolios wie folgt (siehe FP, 2014, Gleichung 16):\n\n$$w_{H}=k(z-\\mu_{z})^+$$\n$$w_{L}=k(z-\\mu_{z})^-$$\n\nHierbei bezeichnet $z$ einen $n x 1$ Vektor der Beta-Perzentil-Ränge $z_{i}=rank(\\beta_{it})$ zum Zeitpunkt der Portfoliokonstruktion, $\\mu_{z}=1_{n}z/n$ den durchschnittlichen Rang, $n$ die Anzahl der Aktien und $1_{n}$ den Einheitsvektor der Dimension $n x 1$. $x^+$ und $x^-$ kennzeichnen die positiven bzw. negativen Elemente eines Vektors $x$. Um sicher zu stellen, dass sich die Gewichte in beiden Portfolios zu 1 summieren, d.h., $1_{n}w_{H}=1$ bzw. $1_{n}w_{L}=1$ gilt, wird die Normalisierungskonstante $k$ definiert als $k=2/1_{n}|z-\\mu_{z}|$. \n\nIn Worten ergibt sich das Gewicht jeder Aktie aus der Rangabweichung der Aktie vom mittleren Rang skaliert mit der (d.h. geteilt durch die) Hälfte der Summe der absoluten Rangabweichungen über alle Aktien. \n\nZur Implementierung der FP Portfolios verwenden wir das tägliche DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihres geschätzten Betas. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. \n\nIm nächsten Schritt generieren wir zwei transformierte Versionen von `demeaned`, die DataFrames `long` und `short`, mit Indikatoren (0/1-Variablen), die jeweils anzeigen, ob eine Aktie an einen entsprechenden Tag in das Long (High-Beta) oder das Short (Low-Beta) Portfolio gehört. \n\nDann erstellen wir das DataFrame `abs_demeaned` mit den absoluten Rangabweichungen. Wir bekommen die normalisierten Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `abs_demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nWir erhalten die beiden DataFrames `long_weights` und `short_weights` mit den täglichen Zeitreihen der Portfoliogewichtsvektoren indem wir das DataFrame `weights` jeweils mit den DataFrames der Portfolio-Positionsindikatoren multiplizieren.\n\nIm letzten Schritt berechnen wir die Zeitreihe der beiden Portfolio-Betas durch zellenweise Multiplikation des DataFrames der Aktienbeta-Zeitreihen (`beta`) mit den DataFrames der Portfoliogewichte und Bilden der Zeilensummen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `bab_weights` zusammen. Diese Funktion benötigt als Eingabe ein DataFrame mit Aktienkurshistorien und Indexwerten. Als Ausgabe der Funktion erhalten wir die beiden DataFrames mit den Portfoliogewichten zu jedem Zeitpunkt, und zwei Zeitreihen mit den gewichteten Betas der Portfolios. \n\nBevor wir mit dem dritten Schritt, der Konstruktion des BAB Faktors, weitermachen, definieren wir unsere bekannten **Lambda** Hilfs-Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\n### Konstruktion des BAB Faktors\n\nKonstruktionsbedingt ist das Portfoliobeta im Long (Low-Beta) Portfolio immer kleiner als das im Short (High-Beta) Portfolio. Wie lässt sich nun eine Long-Short BAB Faktorstrategie implementieren, die marktneutral (Zero-Beta Portfolio) ist? Hierzu müssen die Positionen in den beiden Portfolios gehebelt werden. Konkret benötigen wir eine \"leveraged\" Position im Low-Beta Portfolio und eine \"deleveraged\" Position im High-Beta Portfolio. Das Ziel ist es hierbei, dass die Positionen in den beiden Portfolios jeweils ein Beta von Eins haben. Hat das $L$ ($H$) Portfolio beispielsweise ein Beta von 0,75 (1,4), müssen 1,33 (0,7) Geldeinheiten in das Portfolio investiert werden. Die Finanzierung der Positionen erfolgt dabei über entsprechend entgegengesetzte Positionen im risikolosen Zins um die Strategie selbstfinanzierend zu halten. **Wichtig:** Eine Geldeinheit Long und eine Geldeinheit Short führen nicht zu einem Zero-Beta Faktor! Formal ergibt sich die BAB Faktorstrategierendite folglich als (siehe FP, 2014, Gleichung 17):\n\n$$r^{BAB}_{t+1}=\\frac{1}{\\beta^L_{t}}(r^L_{t+1}-r_{f})-\\frac{1}{\\beta^H_{t}}(r^H_{t+1}-r_{f}),$$\n\nmit $r^L_{t+1}=r^´_{t+1}w_{L}$, $r^H_{t+1}=r^´_{t+1}w_{H}$, $\\beta^L_{t}=\\beta^´_{t}w_{L}$, und $\\beta^H_{t}=\\beta^´_{t}w_{H}$. Im folgenden unterstellen wir zur Vereinfachung einen risikolosen Zins $r_{f}$ von Null. \n\nWir implementieren nun die Konstruktion der marktneutralen BAB Faktorstrategie in der Funktion `bab_strat`. Wie immer halten wir das Faktorportfolio konstant für eine Anzahl von Handelstagen, die durch das Argument *hold* angegeben wird. \n\n**Wichtig:** Wir reduzieren die Zeitfrequenz der DataFrames mit den täglichen (Long/Short) Portfoliogewichtsvektoren und der Zeitreihen der Portfoliobetas auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte/Betas auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.  \n\nWir berechnen separate Zeitreihen der kumulierten Halteperioderenditen für das Long- und das Short-Portfolio (*long_rets* bzw. *short_rets*). Die Faktorrendite ergibt sich als Differenz (Long minus Short) der Portfoliorenditen, jeweils skaliert mit der Inversen des Portfoliobetas.\n\nZusätzlich zur annualisierten Sharpe-Ratio der Strategie gibt uns die Funktion auch die Sharpe-Ratio der Benchmark, d.h., der S&P500 Indexrenditen, zurück. \n\nBerechnen wir nun die Sharpe-Ratios der BAB Strategie mit einer Rebalancingfrequenz von 20 Tagen und der passiven Benchmark (S&P500).\n","srcMarkdownNoYaml":"\n\n\n\n\n\n\n## Hintergrund und Motivation\n\n\n\n\nEine Basisimplikation des Capital Asset Pricing Modells (CAPM) ist, dass alle Investoren in das Portfolio mit der höchsten erwarteten Überschussrendite pro Risikoeinheit (Sharpe Ratio) investieren und ihre Position in diesem Portfolio entsprechend ihrer Risikopräferenz mit Fremdkapital entweder hebeln (\"leveraging\" - erhöhen) oder enthebeln (\"de-leveraging\" – reduzieren). Viele Anleger, wie z.B. Privatpersonen, Pensionsfonds und Investmentfonds, haben jedoch nur eine eingeschränkte (oder gar keine) Möglichkeiten, Leverage (Fremdkapital) einzusetzen, und müssen daher riskante (High-Beta) Wertpapiere übergewichten, anstatt gehebelte Positionen in Low-Beta Aktien einzugehen. Diese aus Leveragebeschränkungen resultierende Präferenz für High-Beta Aktien kann dazu führen, dass im Gleichgewicht risikoreiche Wertpapiere mit hohem Beta niedrigere risikobereinigte Renditen erfordern als Wertpapiere mit niedrigem Beta, für die eine Hebelwirkung (d.h., eine Position unter Einsatz von Fremdkapital) erforderlich ist. Im Ergebnis bedeutet dies: **Low-Beta gleich High-Alpha**, und **High-Beta gleich Low-Alpha!** (Alpha bezeichnet hier risikoadjustierte Renditen)\n\nTatsächlich ist die Wertpapiermarktlinie für US-Aktien im Vergleich zum CAPM zu flach (Black, Jensen und Scholes, 1972) und lässt sich durch das CAPM mit eingeschränkter Kreditaufnahme besser erklären als durch das Standard-CAPM (siehe schon Black, 1972).\n\nIn einem viel zitierten Aufsatz stellen Frazzini und Pedersen (FP) (\"Betting against beta\", Journal of Financial Economics, 2014, p. 1-25) eine \"Long minus Short\" Faktorstrategie vor, mit dem Ziel die oben skizzierte **Beta Anomalie** auszunutzen. Sie konstruieren dabei einen \"Betting Against Beta\" (BAB) Faktor, der im Kern Low-Beta Aktien übergewichtet und High-Beta Aktien untergewichtet. Sie wenden die Faktorkonstruktion auf zahlreiche Assetklassen (US und 20 internationale Aktienmärkte, US-Staatsanleihen und Unternehmensanleihen, Future Märkte) an und können zeigen, dass die Faktorstrategie überall persistente, positive risikoadjustierte Renditen erwirtschaftet.  \n\nIm folgenden implementieren wir die Basisversion der FP BAB Faktorstrategie. \n\n## Beginn der Fallstudie\n\nWir beginnen mit dem Laden der notwendigen Pakete.\n\nWir setzen die BAB Faktorstrategie am Beispiel des S&P500 Universums um. Zunächst laden wir zwei Datensätze in Form von DataFrames, eines für die täglichen Aktienkurshistorien der S&P500 Mitglieder und eines für die Zeitreihe der Indexwerte des S&P500. Wir mergen beide Datensätze in dem DataFrame `joined_df`.\n\nWir werden in drei Schritten die BAB Faktorstrategie von FP implementieren. Zunächst schreiben wir eine Funktion (*calc_beta*), die den renditeprognostizierenden Faktor (das Aktienbeta zum Marktindex) für jede Aktie täglich auf Basis rollierender Zeitfenster berechnet. Danach verwenden wir diesen Faktor in der Funktion *bab_weights* um zwei Faktorportfolios zu bilden. Das Long (Low-Beta) Portfolio enthält Aktien mit niedrigem Beta, und das Short (High-Beta) Portfolio beinhaltet die Aktien, die stärker mit dem Markt variieren. In der dritten Funktion *bab_strat* führen wir alles zusammen, konstruieren den BAB \"Long minus Short\" Faktor, wobei die beiden Portfolios jeweils mit der Inversen ihres Betas skaliert werden, und berechnen für eine gegebene Halteperiode die annualisierte Sharpe-Ratio der Faktorstrategie. \n\n### Ex Ante Betas als Faktor\nDas geschätze $\\beta$ für Aktie $i$ ist definiert durch (siehe FP, 2014, Gleichung 14): \n\n$$\\beta^{TS}_{i}=\\rho\\frac{\\sigma_{i}}{\\sigma_{m}}$$\n\nHierbei sind $\\sigma_{i}$ und $\\sigma_{m}$ die historisch geschätzen Renditevolatilitäten der Aktie $i$ und des Marktes und $\\rho$ deren geschätzte Korrelation. FP schätzen Volatilitäten und Korrelationen separat. Konkret verwenden sie 1-Tages Log-Renditen für Volatilitäten und überlappende 3-Tages Log-Renditen für Korrelationen. Die jeweiligen gleitenden Zeitfenster für die täglichen rollierenden Schätzungen betragen 1 Jahr bei Volatilitäten und 5 Jahre für Korrelationen. \n\nUm den Einfluss von Ausreißern zu mindern werden die obigen (täglichen) Zeitreihen-Betas $\\beta^{TS}_{i}$ in Richtung des Querschnittsmittelwertes $\\beta^{XS}$ über folgende Gleichung geschrumpft (sogenannte \"Shrinkage\"-Schätzung; siehe FP, 2014, Gleichung 15):\n\n$$\\beta_{i}=w_{i}\\beta^{TS}_{i}+(1-w_{i})\\beta^{XS}$$\n\nZur Vereinfachung setzen FP $w=0.6$ und $\\beta^{XS}=1$ für alle Zeitpunkte und Wertpapiere. \n\n\nWir implementieren die Berechnung der FP Betas in der Funktion `calc_beta`. Diese benötigt als Eingabe ein DataFrame mit täglichen Historien an Aktienkursen und Marktindexwerten. Über `apply(lambda...)` erstellen wir jeweils DataFrames mit täglichen Zeitreihen von 1-Tages und überlappenden (kumulativen) 3-Tages Log-Renditen. Diese DataFrames werden über die `rolling`-Funktionalität transformiert in DataFrames mit Standardabweichungen (*stdev*), dem Verhältnis der Aktienvolatilität zur Marktvolatilität (*stdev_ratio*), und Renditekorrelationen (*corr*) mit dem Marktindex (Spalte 'SP_Index'). Die Zeitreihenbetas $\\beta^{TS}_{i}$ ergeben sich aus der zellenweisen Multiplikation von *corr* und *stdev_ratio*. Die geschrumpften Betas $\\beta_{i}$ sind im finalen DataFrame `beta_shrink` enthalten. \n\n### Konstruktion der Long-/Short-Portfolios\n\nUm ihren BAB-Faktor zu konstruieren, ordnen FP alle Wertpapiere im Datensatz zu jedem Zeitpunkt in aufsteigender Reihenfolge auf Grundlage der geschätzten Betas an (Perzentil-Ranking). Die geordneten Wertpapiere werden einem von zwei Portfolios zugewiesen: dem Low-Beta ($L$) und dem High-Beta ($H$) Portfolio. Der FP BAB Faktor basiert darauf, Long in das Low-Beta und Short in das High-Beta Portfolio zu gehen. Das Low- (High-) Beta Portfolio setzt sich aus allen Aktien zusammen, deren Beta unter (über) dem Median-Beta aller Wertpapiere im Datensatz liegt. In jedem Portfolio werden Wertpapiere anhand des Perzentil-Rangs ihres geschätzten Betas gewichtet. D.h., im Low-Beta Portfolio haben Wertpapiere mit niedrigerem Beta größere Gewichte, und im High-Beta Portfolio steigt entsprechend das Gewicht für Wertpapiere mit höherem Beta. Formal ergeben sich die Gewichtsvektoren der Aktien in beiden Portfolios wie folgt (siehe FP, 2014, Gleichung 16):\n\n$$w_{H}=k(z-\\mu_{z})^+$$\n$$w_{L}=k(z-\\mu_{z})^-$$\n\nHierbei bezeichnet $z$ einen $n x 1$ Vektor der Beta-Perzentil-Ränge $z_{i}=rank(\\beta_{it})$ zum Zeitpunkt der Portfoliokonstruktion, $\\mu_{z}=1_{n}z/n$ den durchschnittlichen Rang, $n$ die Anzahl der Aktien und $1_{n}$ den Einheitsvektor der Dimension $n x 1$. $x^+$ und $x^-$ kennzeichnen die positiven bzw. negativen Elemente eines Vektors $x$. Um sicher zu stellen, dass sich die Gewichte in beiden Portfolios zu 1 summieren, d.h., $1_{n}w_{H}=1$ bzw. $1_{n}w_{L}=1$ gilt, wird die Normalisierungskonstante $k$ definiert als $k=2/1_{n}|z-\\mu_{z}|$. \n\nIn Worten ergibt sich das Gewicht jeder Aktie aus der Rangabweichung der Aktie vom mittleren Rang skaliert mit der (d.h. geteilt durch die) Hälfte der Summe der absoluten Rangabweichungen über alle Aktien. \n\nZur Implementierung der FP Portfolios verwenden wir das tägliche DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihres geschätzten Betas. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. \n\nIm nächsten Schritt generieren wir zwei transformierte Versionen von `demeaned`, die DataFrames `long` und `short`, mit Indikatoren (0/1-Variablen), die jeweils anzeigen, ob eine Aktie an einen entsprechenden Tag in das Long (High-Beta) oder das Short (Low-Beta) Portfolio gehört. \n\nDann erstellen wir das DataFrame `abs_demeaned` mit den absoluten Rangabweichungen. Wir bekommen die normalisierten Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `abs_demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nWir erhalten die beiden DataFrames `long_weights` und `short_weights` mit den täglichen Zeitreihen der Portfoliogewichtsvektoren indem wir das DataFrame `weights` jeweils mit den DataFrames der Portfolio-Positionsindikatoren multiplizieren.\n\nIm letzten Schritt berechnen wir die Zeitreihe der beiden Portfolio-Betas durch zellenweise Multiplikation des DataFrames der Aktienbeta-Zeitreihen (`beta`) mit den DataFrames der Portfoliogewichte und Bilden der Zeilensummen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `bab_weights` zusammen. Diese Funktion benötigt als Eingabe ein DataFrame mit Aktienkurshistorien und Indexwerten. Als Ausgabe der Funktion erhalten wir die beiden DataFrames mit den Portfoliogewichten zu jedem Zeitpunkt, und zwei Zeitreihen mit den gewichteten Betas der Portfolios. \n\nBevor wir mit dem dritten Schritt, der Konstruktion des BAB Faktors, weitermachen, definieren wir unsere bekannten **Lambda** Hilfs-Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\n### Konstruktion des BAB Faktors\n\nKonstruktionsbedingt ist das Portfoliobeta im Long (Low-Beta) Portfolio immer kleiner als das im Short (High-Beta) Portfolio. Wie lässt sich nun eine Long-Short BAB Faktorstrategie implementieren, die marktneutral (Zero-Beta Portfolio) ist? Hierzu müssen die Positionen in den beiden Portfolios gehebelt werden. Konkret benötigen wir eine \"leveraged\" Position im Low-Beta Portfolio und eine \"deleveraged\" Position im High-Beta Portfolio. Das Ziel ist es hierbei, dass die Positionen in den beiden Portfolios jeweils ein Beta von Eins haben. Hat das $L$ ($H$) Portfolio beispielsweise ein Beta von 0,75 (1,4), müssen 1,33 (0,7) Geldeinheiten in das Portfolio investiert werden. Die Finanzierung der Positionen erfolgt dabei über entsprechend entgegengesetzte Positionen im risikolosen Zins um die Strategie selbstfinanzierend zu halten. **Wichtig:** Eine Geldeinheit Long und eine Geldeinheit Short führen nicht zu einem Zero-Beta Faktor! Formal ergibt sich die BAB Faktorstrategierendite folglich als (siehe FP, 2014, Gleichung 17):\n\n$$r^{BAB}_{t+1}=\\frac{1}{\\beta^L_{t}}(r^L_{t+1}-r_{f})-\\frac{1}{\\beta^H_{t}}(r^H_{t+1}-r_{f}),$$\n\nmit $r^L_{t+1}=r^´_{t+1}w_{L}$, $r^H_{t+1}=r^´_{t+1}w_{H}$, $\\beta^L_{t}=\\beta^´_{t}w_{L}$, und $\\beta^H_{t}=\\beta^´_{t}w_{H}$. Im folgenden unterstellen wir zur Vereinfachung einen risikolosen Zins $r_{f}$ von Null. \n\nWir implementieren nun die Konstruktion der marktneutralen BAB Faktorstrategie in der Funktion `bab_strat`. Wie immer halten wir das Faktorportfolio konstant für eine Anzahl von Handelstagen, die durch das Argument *hold* angegeben wird. \n\n**Wichtig:** Wir reduzieren die Zeitfrequenz der DataFrames mit den täglichen (Long/Short) Portfoliogewichtsvektoren und der Zeitreihen der Portfoliobetas auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte/Betas auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.  \n\nWir berechnen separate Zeitreihen der kumulierten Halteperioderenditen für das Long- und das Short-Portfolio (*long_rets* bzw. *short_rets*). Die Faktorrendite ergibt sich als Differenz (Long minus Short) der Portfoliorenditen, jeweils skaliert mit der Inversen des Portfoliobetas.\n\nZusätzlich zur annualisierten Sharpe-Ratio der Strategie gibt uns die Funktion auch die Sharpe-Ratio der Benchmark, d.h., der S&P500 Indexrenditen, zurück. \n\nBerechnen wir nun die Sharpe-Ratios der BAB Strategie mit einer Rebalancingfrequenz von 20 Tagen und der passiven Benchmark (S&P500).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel5.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Risikobasierte Faktoren: Stock Beta"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}