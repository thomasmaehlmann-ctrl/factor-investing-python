{"title":"Preisbasierte Faktoren: Momentum und Reversal","markdown":{"yaml":{"title":"Preisbasierte Faktoren: Momentum und Reversal"},"headingText":"Hintergrund und Motivation","containsRefs":false,"markdown":"\n\n\n\n\n\n\n\nBei **Momentum** bzw. **Reversal** handelt es sich um Trendfolge- bzw. Trendumkehr-Strategien. Der zugrundeliegende Faktor ist dabei die Aktienrendite gemessen über einen vergangenen Zeitraum. Bei Momentum basiert die Wette darauf dass zumindest kurzfristig Past Winner auch Future Winner sind, bzw. Past Loser auch Future Loser bleiben. Bei Reversal ist die Wette genau umgekehrt, Winner werden zu Losern und Loser zu Winnern. \n\nDer **Momentum-Effekt** wurde in der im Jahr 1993 erschienenen Studie (*Returns to Buying Winners and Selling Losers: Implications for Stock Market Efficiency, Journal of Finance, S. 65-91*) von Jegadeesh und Titman erstmals umfangreich quantitativ belegt. Die Autoren zeigten für den Zeitraum von 1965 bis 1989, dass eine Handelsstrategie, welche die 10% der stärksten (schwächsten) Aktien kauft (leerverkauft), über einen Zeitraum von 3 bis 12 Monaten deutlich positive Renditen erzielt. Konkret berechnen die Autoren für eine jeweils 6-monatige Ranking- und Holding-Periode eine jährliche Überrendite von 12,01% vor Transaktionskosten. Eine lesenswerte Zusammenfassung der umfangreichen Momentum-Literatur gibt Gränitz (2014, S. 12-39). \n\nDas Phänomen der kurzfristigen Renditeumkehr, der sogenannte **Short-Term Reversal (STR) Effekt**, ist ein am Aktienmarkt seit mehr als 40 Jahren etabliertes Phänomen, das sich als robust und als ökonomisch und statistisch signifikant erwiesen hat. Jegadeesh (1990) zum Beispiel dokumentiert Gewinne von etwa 2% pro Monat über den Zeitraum 1934-1987 mit einer Umkehrstrategie, die Aktien auf der Grundlage ihrer Vormonatsrenditen kauft und verkauft und sie dann für einen Monat hält. Diese Gewinne lassen sich nicht durch direkte Transaktionskosten erklären. Weitere wichtige Arbeiten zum STR Effekt liefern Lehmann (1990), Lo und MacKinlay (1990), Nagel (2012), und Da, Liu und Schaumburg (2014). \n\n\n## Beginn der Fallstudie\n\nFür unsere beispielhafte Implementierung einer faktorbasierten Momentum bzw. Reversal Strategie wählen wir als Anlageuniversum die Aktien des S&P500. Wir laden Preishistorien für alle Indexmitglieder für den Zeitraum 3.1.2017 - 14.11.2019 aus Yahoo Finance.  \n\n### Implementierung 1: gleichgewichtete Dezil-Portfolios\n\nFaktorstrategien können auf unterschiedliche Arten implementiert werden. Ein Standardverfahren ist es Aktien nach den Ausprägungen eines Faktors (hier: vergangene Renditen) in Dezile zu sortieren. Um die Strategie marktneutral zu halten wird in die Aktien des Dezil's 10 \"Long gegangen\", und das Dezil 1 wird \"geshortet\". Die Strategie ist also ein Long-Short (Dezil 10-1) Ansatz. Die Aktien innerhalb der Dezile werden dabei am Anfang gleichgewichtet. Nach einer festgelegten Halteperiode kommt es zu einem Rebalancing (Neubestimmung der Dezile und Rückführung der Positionen auf eine Gleichgewichtung). \n\nLassen Sie uns beginnen und die Aktien des S&P500 an jedem Handelstag anhand ihrer vergangenen 20-Tagesrendite in Gruppen sortieren. Zunächst berechnen wir für jeden Tag t die diskrete Rendite für den Zeitraum von t-1 bis t-21. Dies geschieht durch `px.shift(1).pct_change(20)`. Wir speichern die Renditen im DataFrame `ret_df`. Dann bringen wir die Aktien über die Methode `rank(axis=1, pct=True)` in eine Perzentil-Rankordnung gemäß der vergangenen 20-Tagesrendite. Aus den Perzentilen können wir Dezile generieren indem wir mit 10 multiplizieren (`mul(10)`) und dann auf die nächste ganze Zahl aufrunden (`np.ceil`). Wollen wir Aktien alternativ in Quintile sortieren, multiplizieren wir einfach mit 5 (`mul(5)`). Wichtig: durch die Festlegung `ascending=False` werden Aktien mit den höchsten (geringsten) Renditen in Gruppe 1 (10) sortiert. Äquivalent werden bei `ascending=True` die Past Winner in Gruppe 10 und die Past Loser in Gruppe 1 sortiert. \n\nWir transformieren das DataFrame `rank_df` nun in ein DataFrame mit Positionsindikatoren: -1 für eine Short Position in Dezil 1 Aktien, 0 für eine Flat (d.h. keine) Position in Aktien der Dezile 2 bis 9, und 1 für eine Long Position in Dezil 10 Aktien. \n\n**Beachten Sie**: Da wir Long in Dezil 10 und Short in Dezil 1 gehen, implementieren wir durch die Wahl von `ascending=True` eine Momentum Strategie, und durch `ascending=False` eine Reversal Strategie!\n\nFühren wir nun alles zusammen in der Funktion `weights_dc_equal`. Diese Funktion erfordert als Eingabe ein DataFrame mit Aktienpreisen (*price*), die Angabe des Zeitraums (*lookback*) für die Berechnung der vergangenen diskreten Rendite als Ranking-Faktor, und die Anzahl der Tage (*lag*) die bis zur Implementierung der Strategie vergehen (sollen). \n\nZudem definieren wir zwei **Lambda** Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\nIm folgenden berechnen wir zunächst für jeden Handelstag die nicht-normierten Aktiengewichte (-1: Short; 0: Flat; 1: Long) durch Anwendung unserer Funktion `weights_dc_equal`. Das resultierende DataFrame nennen wir `port`. Dann legen wir die Anzahl der Handelstage (*hold*) fest, für die wir das Portfolio halten wollen ohne die Gewichte umzuschichten. \n\nIm letzten Schritt reduzieren wir die Zeitfrequenz von `port` auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.   \n\nDann berechnen wir die kumulativen Renditen jeder Aktie für die gewählte Portfoliohaltedauer. Hierzu verwenden wir die vorher definierte Lambda-Funktion `compound`.  \n\nDanach multiplizieren wir für jede der einzelnen Halteperioden die kumulativen Aktienrenditen mit den Positionsindikatoren (-1, 0, 1), summieren die Produkte über alle Aktien auf, und teilen durch die Summe aller offen (Long und Short) Positionen um eine gleichgewichtete Portfoliorendite zu bekommen. Die resultierende Zeitreihe der kumulativen Portfoliorenditen nennen wir `portf_rets`. Sie hat dieselbe Zeitfrequenz wie *freq*, die Portfoliohaltedauer in Anzahl Handelstage. Wenden wir unsere Lambda-Funktion `daily_sr`auf die Zeitreihe der Portfoliorenditen an und skalieren mit `np.sqrt(252/hold)` erhalten wir die annualisierte Sharpe-Ratio der Strategie. \n\nLassen Sie uns nun die obigen Schritte in der Strategie-Funktion `strat_dc_equal` zusammenfassen. Wir benötigen ein DataFrame (*prices*) mit Aktienkursen, die Länge der lookback (*lb*) Periode zur Berechnung des Preisfaktors, und die Länge der Portfoliohaltedauer (*hold*). \n\nFühren wir die Strategie nun beispielhaft mit einer Halteperiode von einem Tag aus. Die Aktien des S&P500 werden anhand ihrer vergangenen 5-Tagesrendite sortiert. Da in der Funktion `weights_dc_equal` `ascending=False` festgelegt ist, gehen wir also Long in die extremen 10% der vergangenen 5-Tages Loser und Short in die extremen 10% der vergangenen 5-Tages Winner. Wir wetten also auf ein Short-Term Reversal!\n\n### Implementierung 2: Marktwert-gewichtete Dezil-Portfolios\n\n\n\nAlternativ zur Gleichgewichtung bei Portfoliobildung können die Aktien in den beiden Portfolios (Dezil 10 und 1) auch Marktwert-gewichtet (value-weighted) werden. Hierzu benötigt man die Informationen zur täglichen Marktkapitalisierung (Schlusskurs * Anzahl emittierter Aktien) einer Aktie. Zur Veranschaulichung des Konzepts und der Implementierung verwenden wir im folgenden nur Daten zu Kursen und zur Marktkapitalisierung der S&P500 Aktien für einen Monat (18.11.2019 - 17.12.2019). Wir generieren aus dem Excel File *\"SnP500 1monat Schlusskurse und MarketCaps\"* zwei DataFrames: `df.px` mit den Schlusskursen und `df.market_cap` mit der täglichen Marktkapitalisierung (in Dollar) der S&P500 Aktien. \n\nNachdem wir wie oben unser DataFrame `rank_df` mit den Positionsindikatoren (-1: Short; 0: Flat; 1: Long) erstellt haben, generieren wir daraus ein Dataframe `ranks_long` mit Positionsindikatoren (Einsen und Nullen) für Long Positionen und ein separates (`ranks_short`) für Short Positionen. Wir gewichten die \"Einsen\" mit der aktuellen Marktkapitalisierung der Aktie und normieren (teilen) durch die Summe der Marktkapitalsierungen aller Aktien in jedem der beiden Portfolios. Im Ergebnis erhalten wir ein DataFrame mit den täglichen Marktwert-basierten Gewichten für das Long Portfolio und eins für das Short Portfolio. Fassen wir die einzelnen Schritte in der Funktion `weights_dc_value` zusammen. \n\nWir berechnen nun für das Long und das Short Portfolio separat die täglichen Gewichte, und verwenden die Gewichte zum Zeitpunkt t-1 für eine Halteperiode die in t beginnt. Mit diesen Gewichten multiplizieren wir die kumulativen Renditen der Aktien über die Halteperiode um die Portfoliorendite der Halteperiode zu bekommen. Die Strategierendite der Halteperiode ist die Differenz zwischen der Halteperiodenrendite des Long und des Short Portfolios. Wir fassen diese Schritte in der Strategiefunktion `strat_dc_value` zusammen. \n\n### Implementierung 3: Gewichte nach Frazzini und Pedersen (2014)\n\n\n\nDer Ansatz von Frazzini und Pedersen (FP) (*Betting Against Beta, Journal of Financial Economics, 2014, S. 1-25*) sieht nicht die Bildung von Dezilen (oder Quintilen, etc.) vor. Im Gegensatz dazu wird in jede Aktie investiert, und zwar abhängig davon wie stark und in welche Richtung der Perzentil-Rang einer Aktie vom durchschnittlichen Rang aller Aktien abweicht. In Aktien mit negativen Abweichungen wird Short gegangen und in Aktien mit positiven Abweichungen wird eine Long Position aufgebaut. Das Gewicht jeder Aktie ergibt sich aus der Rangabweichung der Aktie vom mittleren Rang skaliert mit der (d.h. geteilt durch die) Hälfte der Summe der absoluten Rangabweichungen über alle Aktien. Das Long Portfolio hat damit wieder ein Gewicht von 1, und das Short Portfolio von -1. \n\nZur Implementierung der FP Gewichte erstellen wir das gewohnte (tägliche) DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihrer Rendite über eine vergangene lookback Periode. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. Zusätzlich enthält das DataFrame `abs_demeaned` die absoluten Rangabweichungen. Wir bekommen die finalen FP Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `weights_fp` zusammen. Alle weiteren Schritte erfolgen analog zur obigen Vorgehensweise. Die Strategiefunktion nenne ich `strat_fp`.  \n\n### Optimierung der Lookback und Halteperioden\n\nLassen Sie uns zum Abschluss unsere Momentum bzw. Reversal Faktorstrategie optimieren indem wir mit einem \"Brute Force\" Ansatz nach der für die Backtestperiode optimalen Länge des Lookback Fensters und der Halteperiode suchen. Beachten Sie das **Overfitting Risiko**: die optimalen Längen ermittelt für die Backtestperiode werden mit hoher Wahrscheinlichkeit nicht optimal für eine *Out-of-Sample* Periode sein. \n\nWir erstellen dabei ein DataFrame `ddf` mit Zeilen für unterschiedliche Halteperioden (zwischen 1 und 10 Tagen mit Schrittlänge 2 Tagen) und Spalten für unterschiedliche Lookback Fensterlängen (zwischen 2 und 20 Tagen mit Schrittlänge 2 Tagen). Die Zellen des DataFrames enthalten die entsprechenden annualisierten Strategie Sharpe-Ratios. \n","srcMarkdownNoYaml":"\n\n\n\n\n\n\n## Hintergrund und Motivation\n\nBei **Momentum** bzw. **Reversal** handelt es sich um Trendfolge- bzw. Trendumkehr-Strategien. Der zugrundeliegende Faktor ist dabei die Aktienrendite gemessen über einen vergangenen Zeitraum. Bei Momentum basiert die Wette darauf dass zumindest kurzfristig Past Winner auch Future Winner sind, bzw. Past Loser auch Future Loser bleiben. Bei Reversal ist die Wette genau umgekehrt, Winner werden zu Losern und Loser zu Winnern. \n\nDer **Momentum-Effekt** wurde in der im Jahr 1993 erschienenen Studie (*Returns to Buying Winners and Selling Losers: Implications for Stock Market Efficiency, Journal of Finance, S. 65-91*) von Jegadeesh und Titman erstmals umfangreich quantitativ belegt. Die Autoren zeigten für den Zeitraum von 1965 bis 1989, dass eine Handelsstrategie, welche die 10% der stärksten (schwächsten) Aktien kauft (leerverkauft), über einen Zeitraum von 3 bis 12 Monaten deutlich positive Renditen erzielt. Konkret berechnen die Autoren für eine jeweils 6-monatige Ranking- und Holding-Periode eine jährliche Überrendite von 12,01% vor Transaktionskosten. Eine lesenswerte Zusammenfassung der umfangreichen Momentum-Literatur gibt Gränitz (2014, S. 12-39). \n\nDas Phänomen der kurzfristigen Renditeumkehr, der sogenannte **Short-Term Reversal (STR) Effekt**, ist ein am Aktienmarkt seit mehr als 40 Jahren etabliertes Phänomen, das sich als robust und als ökonomisch und statistisch signifikant erwiesen hat. Jegadeesh (1990) zum Beispiel dokumentiert Gewinne von etwa 2% pro Monat über den Zeitraum 1934-1987 mit einer Umkehrstrategie, die Aktien auf der Grundlage ihrer Vormonatsrenditen kauft und verkauft und sie dann für einen Monat hält. Diese Gewinne lassen sich nicht durch direkte Transaktionskosten erklären. Weitere wichtige Arbeiten zum STR Effekt liefern Lehmann (1990), Lo und MacKinlay (1990), Nagel (2012), und Da, Liu und Schaumburg (2014). \n\n\n## Beginn der Fallstudie\n\nFür unsere beispielhafte Implementierung einer faktorbasierten Momentum bzw. Reversal Strategie wählen wir als Anlageuniversum die Aktien des S&P500. Wir laden Preishistorien für alle Indexmitglieder für den Zeitraum 3.1.2017 - 14.11.2019 aus Yahoo Finance.  \n\n### Implementierung 1: gleichgewichtete Dezil-Portfolios\n\nFaktorstrategien können auf unterschiedliche Arten implementiert werden. Ein Standardverfahren ist es Aktien nach den Ausprägungen eines Faktors (hier: vergangene Renditen) in Dezile zu sortieren. Um die Strategie marktneutral zu halten wird in die Aktien des Dezil's 10 \"Long gegangen\", und das Dezil 1 wird \"geshortet\". Die Strategie ist also ein Long-Short (Dezil 10-1) Ansatz. Die Aktien innerhalb der Dezile werden dabei am Anfang gleichgewichtet. Nach einer festgelegten Halteperiode kommt es zu einem Rebalancing (Neubestimmung der Dezile und Rückführung der Positionen auf eine Gleichgewichtung). \n\nLassen Sie uns beginnen und die Aktien des S&P500 an jedem Handelstag anhand ihrer vergangenen 20-Tagesrendite in Gruppen sortieren. Zunächst berechnen wir für jeden Tag t die diskrete Rendite für den Zeitraum von t-1 bis t-21. Dies geschieht durch `px.shift(1).pct_change(20)`. Wir speichern die Renditen im DataFrame `ret_df`. Dann bringen wir die Aktien über die Methode `rank(axis=1, pct=True)` in eine Perzentil-Rankordnung gemäß der vergangenen 20-Tagesrendite. Aus den Perzentilen können wir Dezile generieren indem wir mit 10 multiplizieren (`mul(10)`) und dann auf die nächste ganze Zahl aufrunden (`np.ceil`). Wollen wir Aktien alternativ in Quintile sortieren, multiplizieren wir einfach mit 5 (`mul(5)`). Wichtig: durch die Festlegung `ascending=False` werden Aktien mit den höchsten (geringsten) Renditen in Gruppe 1 (10) sortiert. Äquivalent werden bei `ascending=True` die Past Winner in Gruppe 10 und die Past Loser in Gruppe 1 sortiert. \n\nWir transformieren das DataFrame `rank_df` nun in ein DataFrame mit Positionsindikatoren: -1 für eine Short Position in Dezil 1 Aktien, 0 für eine Flat (d.h. keine) Position in Aktien der Dezile 2 bis 9, und 1 für eine Long Position in Dezil 10 Aktien. \n\n**Beachten Sie**: Da wir Long in Dezil 10 und Short in Dezil 1 gehen, implementieren wir durch die Wahl von `ascending=True` eine Momentum Strategie, und durch `ascending=False` eine Reversal Strategie!\n\nFühren wir nun alles zusammen in der Funktion `weights_dc_equal`. Diese Funktion erfordert als Eingabe ein DataFrame mit Aktienpreisen (*price*), die Angabe des Zeitraums (*lookback*) für die Berechnung der vergangenen diskreten Rendite als Ranking-Faktor, und die Anzahl der Tage (*lag*) die bis zur Implementierung der Strategie vergehen (sollen). \n\nZudem definieren wir zwei **Lambda** Funktionen:\n    \n    1. \"compound\" berechnet aus dem Eingabe-Array x kumulative Mehr-Tagesrenditen;\n    2. \"daily_sr\" berechnet aus einem Array von Tagesrenditen die tägliche Sharpe-Ratio;\n\nIm folgenden berechnen wir zunächst für jeden Handelstag die nicht-normierten Aktiengewichte (-1: Short; 0: Flat; 1: Long) durch Anwendung unserer Funktion `weights_dc_equal`. Das resultierende DataFrame nennen wir `port`. Dann legen wir die Anzahl der Handelstage (*hold*) fest, für die wir das Portfolio halten wollen ohne die Gewichte umzuschichten. \n\nIm letzten Schritt reduzieren wir die Zeitfrequenz von `port` auf die Länge (*hold*) der gewählten Portfoliohalteperiode, setzen die Gewichte auf die Werte die zu Beginn der Halteperiode gelten (über `.first()`), und wählen `.shift(1)`, da in t nur die Gewichte die zum Zeitpunkt t-1 bekannt sind implementiert werden können.   \n\nDann berechnen wir die kumulativen Renditen jeder Aktie für die gewählte Portfoliohaltedauer. Hierzu verwenden wir die vorher definierte Lambda-Funktion `compound`.  \n\nDanach multiplizieren wir für jede der einzelnen Halteperioden die kumulativen Aktienrenditen mit den Positionsindikatoren (-1, 0, 1), summieren die Produkte über alle Aktien auf, und teilen durch die Summe aller offen (Long und Short) Positionen um eine gleichgewichtete Portfoliorendite zu bekommen. Die resultierende Zeitreihe der kumulativen Portfoliorenditen nennen wir `portf_rets`. Sie hat dieselbe Zeitfrequenz wie *freq*, die Portfoliohaltedauer in Anzahl Handelstage. Wenden wir unsere Lambda-Funktion `daily_sr`auf die Zeitreihe der Portfoliorenditen an und skalieren mit `np.sqrt(252/hold)` erhalten wir die annualisierte Sharpe-Ratio der Strategie. \n\nLassen Sie uns nun die obigen Schritte in der Strategie-Funktion `strat_dc_equal` zusammenfassen. Wir benötigen ein DataFrame (*prices*) mit Aktienkursen, die Länge der lookback (*lb*) Periode zur Berechnung des Preisfaktors, und die Länge der Portfoliohaltedauer (*hold*). \n\nFühren wir die Strategie nun beispielhaft mit einer Halteperiode von einem Tag aus. Die Aktien des S&P500 werden anhand ihrer vergangenen 5-Tagesrendite sortiert. Da in der Funktion `weights_dc_equal` `ascending=False` festgelegt ist, gehen wir also Long in die extremen 10% der vergangenen 5-Tages Loser und Short in die extremen 10% der vergangenen 5-Tages Winner. Wir wetten also auf ein Short-Term Reversal!\n\n### Implementierung 2: Marktwert-gewichtete Dezil-Portfolios\n\n\n\nAlternativ zur Gleichgewichtung bei Portfoliobildung können die Aktien in den beiden Portfolios (Dezil 10 und 1) auch Marktwert-gewichtet (value-weighted) werden. Hierzu benötigt man die Informationen zur täglichen Marktkapitalisierung (Schlusskurs * Anzahl emittierter Aktien) einer Aktie. Zur Veranschaulichung des Konzepts und der Implementierung verwenden wir im folgenden nur Daten zu Kursen und zur Marktkapitalisierung der S&P500 Aktien für einen Monat (18.11.2019 - 17.12.2019). Wir generieren aus dem Excel File *\"SnP500 1monat Schlusskurse und MarketCaps\"* zwei DataFrames: `df.px` mit den Schlusskursen und `df.market_cap` mit der täglichen Marktkapitalisierung (in Dollar) der S&P500 Aktien. \n\nNachdem wir wie oben unser DataFrame `rank_df` mit den Positionsindikatoren (-1: Short; 0: Flat; 1: Long) erstellt haben, generieren wir daraus ein Dataframe `ranks_long` mit Positionsindikatoren (Einsen und Nullen) für Long Positionen und ein separates (`ranks_short`) für Short Positionen. Wir gewichten die \"Einsen\" mit der aktuellen Marktkapitalisierung der Aktie und normieren (teilen) durch die Summe der Marktkapitalsierungen aller Aktien in jedem der beiden Portfolios. Im Ergebnis erhalten wir ein DataFrame mit den täglichen Marktwert-basierten Gewichten für das Long Portfolio und eins für das Short Portfolio. Fassen wir die einzelnen Schritte in der Funktion `weights_dc_value` zusammen. \n\nWir berechnen nun für das Long und das Short Portfolio separat die täglichen Gewichte, und verwenden die Gewichte zum Zeitpunkt t-1 für eine Halteperiode die in t beginnt. Mit diesen Gewichten multiplizieren wir die kumulativen Renditen der Aktien über die Halteperiode um die Portfoliorendite der Halteperiode zu bekommen. Die Strategierendite der Halteperiode ist die Differenz zwischen der Halteperiodenrendite des Long und des Short Portfolios. Wir fassen diese Schritte in der Strategiefunktion `strat_dc_value` zusammen. \n\n### Implementierung 3: Gewichte nach Frazzini und Pedersen (2014)\n\n\n\nDer Ansatz von Frazzini und Pedersen (FP) (*Betting Against Beta, Journal of Financial Economics, 2014, S. 1-25*) sieht nicht die Bildung von Dezilen (oder Quintilen, etc.) vor. Im Gegensatz dazu wird in jede Aktie investiert, und zwar abhängig davon wie stark und in welche Richtung der Perzentil-Rang einer Aktie vom durchschnittlichen Rang aller Aktien abweicht. In Aktien mit negativen Abweichungen wird Short gegangen und in Aktien mit positiven Abweichungen wird eine Long Position aufgebaut. Das Gewicht jeder Aktie ergibt sich aus der Rangabweichung der Aktie vom mittleren Rang skaliert mit der (d.h. geteilt durch die) Hälfte der Summe der absoluten Rangabweichungen über alle Aktien. Das Long Portfolio hat damit wieder ein Gewicht von 1, und das Short Portfolio von -1. \n\nZur Implementierung der FP Gewichte erstellen wir das gewohnte (tägliche) DataFrame `ranks` mit den Perzentil-Rängen der Aktien gemäß ihrer Rendite über eine vergangene lookback Periode. Daraus erstellen wir ein neues DataFrame `demeaned` mit Rangabweichungen indem wir jeweils den Zeilenmittelwert (`ranks.mean(axis=1)`) der Ränge vom Rang einer Aktie abziehen. Zusätzlich enthält das DataFrame `abs_demeaned` die absoluten Rangabweichungen. Wir bekommen die finalen FP Gewichte (DataFrame `weights`) indem wir die Zeilenwerte von `demeaned` durch die Hälfte der korrespondierenden Zeilensumme von `abs_demeaned` teilen. \n\nFassen wir diese Schritte nun in der Gewichtsfunktion `weights_fp` zusammen. Alle weiteren Schritte erfolgen analog zur obigen Vorgehensweise. Die Strategiefunktion nenne ich `strat_fp`.  \n\n### Optimierung der Lookback und Halteperioden\n\nLassen Sie uns zum Abschluss unsere Momentum bzw. Reversal Faktorstrategie optimieren indem wir mit einem \"Brute Force\" Ansatz nach der für die Backtestperiode optimalen Länge des Lookback Fensters und der Halteperiode suchen. Beachten Sie das **Overfitting Risiko**: die optimalen Längen ermittelt für die Backtestperiode werden mit hoher Wahrscheinlichkeit nicht optimal für eine *Out-of-Sample* Periode sein. \n\nWir erstellen dabei ein DataFrame `ddf` mit Zeilen für unterschiedliche Halteperioden (zwischen 1 und 10 Tagen mit Schrittlänge 2 Tagen) und Spalten für unterschiedliche Lookback Fensterlängen (zwischen 2 und 20 Tagen mit Schrittlänge 2 Tagen). Die Zellen des DataFrames enthalten die entsprechenden annualisierten Strategie Sharpe-Ratios. \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"css":["styles.css"],"output-file":"kapitel2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"smooth-scroll":true,"title":"Preisbasierte Faktoren: Momentum und Reversal"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}